##### CSRF 跨站点请求伪造

攻击者可以盗用你的信息，以你的名义发起恶意请求；

##### 攻击原理

1.用户A访问可信网站A，并登陆，服务端返回认证信息到浏览器cookie；

2.在不退出网站A的情况下，用户A在访问一个不可信或者存在Xss工具的网站，获取了攻击性的代码，并且该代码发起一个请求访问网站A，发送恶意信息；

3.浏览器在就收到该请求之后，在用户不知情的情况下携带cookie信息，发送信息到网站A，网站A认为是合法的请求，但是实际恶意伪造的请求，执行一些非法的操作；

##### 防御措施

防御措施有三种：

第一种：验证请求头中携带的referer参数的数据，referer中携带请求发起页面的url，可以在服务器端拦截请求，校验referer字段判断请求是否来自于可信域；来自可信域的都是合法的请求，其他的则为不合法请求；

该方法的优点就是简单易操作，在项目初期只需要关注业务代码，后期安全整改的时候只需要在请求入口处田间一个过滤器，就可以完美防护；

缺点是容易被绕过，因为部分浏览器支持手动修改referer，同时部分的三方的ajax类型也允许添加header头信息，从而也可以伪造；

第二种：在请求地址中添加token并验证；

在用户第一次登陆系统之后后台生成一个随机token并发送到浏览器端，浏览器端在后期的请求过程中全部携带该token新在请求地中，后台拦截器拦截验证该token是否合法，以此来区分合法请求以及不合法请求；

该方法相比referer安全，生成的token可以存在后台session中，前端可以缓存在前端的缓存中（sessionstorage/localstorage），在发送请求之后对比session以及请求中的token是否一致。

但是该方法的难点在于怎么把token添加到请求中去，对于get请求直接将token添加在url之后，post求情的则需要构建form表单，将 token作为一个参数传递给后台；

同时token的自身的安全也存在问题，因为部分网站允许输入网址等信息，用户输入的网址在页面展示并且点击后打开连接的时候也会携带token到指定网站，制定网站就是恶意网站的话就花获取该token发起恶意的请求；就是限制本站内的请求才加token，外部网站不添加token，但是在发情请求的时候还是会发送referer参数到外部网站服务器端，服务器端获取referer参数可以从中获取token，继而继续发送恶意请求；

第三种：在请求头中添加自定义属性并验证；

该方法的本质也是使用token来进行验证，与前一中方法的不同之处在于并不是将token添加到请求地址中，而是将token添加到请求头之中，通过ajax或者其他三方的xmlhttprequest库，在发送请求是在请求头中添加自定义参数并携带token；该问题解决了token被恶意获取的问题，恶意网站不会通过请求地址以及referee获取到token；

该方法在浏览器请求静态资源是不会添加token，所以对于一些有中间处理页面处理业务逻辑的场景可能存在缺陷，但是对于当前的前后端分离的单页面则不存在该问题；